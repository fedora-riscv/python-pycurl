From 3e521e118e99fbe843946eac8dc7fafcfbdbd009 Mon Sep 17 00:00:00 2001
From: Kamil Dudka <kdudka@redhat.com>
Date: Fri, 25 Oct 2013 15:20:32 +0200
Subject: [PATCH 1/3] python3: apply python3.patch from archlinux

https://aur.archlinux.org/packages/py/python3-pycurl/python3-pycurl.tar.gz
---
 src/pycurl.c |  456 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 455 insertions(+), 1 deletions(-)

diff --git a/src/pycurl.c b/src/pycurl.c
index 72bd00f..9b27370 100644
--- a/src/pycurl.c
+++ b/src/pycurl.c
@@ -139,6 +139,18 @@ static void pycurl_ssl_cleanup(void);
 #  define PYCURL_END_ALLOW_THREADS
 #endif
 
+#if PY_MAJOR_VERSION < 3
+#define Py_TYPE(x) (x)->ob_type
+#endif
+
+#if PY_MAJOR_VERSION >= 3
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_AsLong                 PyLong_AsLong
+#endif
+
+
 /* Calculate the number of OBJECTPOINT options we need to store */
 #define OPTIONS_SIZE    ((int)CURLOPT_LASTENTRY % 10000)
 #define MOPTIONS_SIZE   ((int)CURLMOPT_LASTENTRY % 10000)
@@ -274,6 +286,33 @@ typedef struct {
 #  define PY_LONG_LONG LONG_LONG
 #endif
 
+int PyUnicode_AsStringAndSize(PyObject *obj, char **buffer, Py_ssize_t *length)
+{
+	Py_ssize_t pysize = PyUnicode_GetSize(obj);
+	wchar_t * str = (wchar_t *) malloc((pysize + 1) * sizeof(wchar_t));
+	PyUnicode_AsWideChar((PyUnicodeObject *) obj, str, pysize);
+	str[pysize] = '\0';
+
+    /* measure size */
+	size_t csize = wcstombs(0, str, 0);
+	if( csize == (size_t) -1 )
+	{
+		free(str);
+		return -1; 
+	}
+
+	char *cstr = (char *) malloc(csize + 1);
+
+    /* convert */
+	wcstombs(cstr, str, csize + 1);
+	*buffer = cstr;
+	if( length )
+		*length = csize;
+	free(str);
+	return 0;
+}
+
+
 /* Like PyString_AsString(), but set an exception if the string contains
  * embedded NULs. Actually PyString_AsStringAndSize() already does that for
  * us if the `len' parameter is NULL - see Objects/stringobject.c.
@@ -283,7 +322,11 @@ static char *PyString_AsString_NoNUL(PyObject *obj)
 {
     char *s = NULL;
     Py_ssize_t r;
+#if PY_MAJOR_VERSION >= 3
+    r = PyUnicode_AsStringAndSize(obj, &s, NULL);
+#else
     r = PyString_AsStringAndSize(obj, &s, NULL);
+#endif
     if (r != 0)
         return NULL;    /* exception already set */
     assert(s != NULL);
@@ -308,7 +351,11 @@ static PyObject *convert_slist(struct curl_slist *slist, int free_flags)
         if (slist->data == NULL) {
             v = Py_None; Py_INCREF(v);
         } else {
+#if PY_MAJOR_VERSION >= 3
+            v = PyUnicode_FromString(slist->data);
+#else
             v = PyString_FromString(slist->data);
+#endif
         }
         if (v == NULL || PyList_Append(ret, v) != 0) {
             Py_XDECREF(v);
@@ -374,7 +421,11 @@ static PyObject *convert_certinfo(struct curl_certinfo *cinfo)
             } else {
                 const char *sep = strchr(field, ':');
                 if (!sep) {
+#if PY_MAJOR_VERSION >= 3
+                    field_tuple = PyUnicode_FromString(field);
+#else
                     field_tuple = PyString_FromString(field);
+#endif
                 } else {
                     field_tuple = Py_BuildValue("s#s", field, (int)(sep - field), sep+1);
                 }
@@ -872,7 +923,7 @@ do_curlshare_setopt(CurlShareObject *self, PyObject *args)
 
     /* Handle the case of integer arguments */
     if (PyInt_Check(obj)) {
-        long d = PyInt_AsLong(obj);
+        long d = PyLong_AsLong(obj);
         if (d != CURL_LOCK_DATA_COOKIE && d != CURL_LOCK_DATA_DNS) {
             goto error;
         }
@@ -998,6 +1049,8 @@ util_curl_init(CurlObject *self)
     return (0);
 }
 
+size_t default_write_callback(char *ptr, size_t size, size_t nmemb, void *stream);
+
 /* constructor - this is a module-level function returning a new instance */
 static CurlObject *
 do_curl_new(PyObject *dummy)
@@ -1020,6 +1073,18 @@ do_curl_new(PyObject *dummy)
     res = util_curl_init(self);
     if (res < 0)
             goto error;
+
+#if PY_MAJOR_VERSION >= 3
+    res = curl_easy_setopt(self->handle, CURLOPT_WRITEFUNCTION, default_write_callback);
+    if (res != CURLE_OK) {
+        goto error;
+    }
+    res = curl_easy_setopt(self->handle, CURLOPT_WRITEDATA, self);
+    if (res != CURLE_OK) {
+        goto error;
+    }
+#endif
+ 
     /* Success - return new object */
     return self;
 
@@ -1176,7 +1241,12 @@ do_curl_errstr(CurlObject *self)
         return NULL;
     }
     self->error[sizeof(self->error) - 1] = 0;
+
+#if PY_MAJOR_VERSION >= 3
+    return PyUnicode_FromString(self->error);
+#else
     return PyString_FromString(self->error);
+#endif
 }
 
 
@@ -1315,6 +1385,50 @@ write_callback(char *ptr, size_t size, size_t nmemb, void *stream)
     return util_write_callback(0, ptr, size, nmemb, stream);
 }
 
+size_t
+default_write_callback(char *ptr, size_t size, size_t nmemb, void *stream)
+{
+    CurlObject *obj = (CurlObject *)stream;
+    PyThreadState *tmp_state;
+    CurlObject *self = (CurlObject *)stream;
+
+    /* acquire thread */
+    int ret = 0;
+    tmp_state = get_thread_state(self);
+    if (tmp_state == NULL)
+        return ret;
+    PyEval_AcquireThread(tmp_state);
+
+    if(obj->writedata_fp != NULL) 
+    {
+        /** 
+         * I'd prefer this code, but
+         * PyFile_WriteObject converts the object to str or repr, which are of type str
+         * and the write() fn expects bytes or buffer ...
+         */
+/* 
+        PyObject *w = PyBytes_FromStringAndSize(ptr, size*nmemb);
+        printf("writedata_fp %p w %p s %i\n", obj->writedata_fp, w, PyBytes_GET_SIZE(w));
+        Py_INCREF(w);
+        if( PyFile_WriteObject(w, obj->writedata_fp, Py_PRINT_RAW) != 0 )
+        {
+            PyErr_Print();
+            ret = -1;
+        }
+
+        Py_DECREF(w);
+*/
+        int fd = PyObject_AsFileDescriptor(((CurlObject *)stream)->writedata_fp);
+        ret = write(fd, ptr, size*nmemb);
+    }else
+    {
+        fwrite(ptr, size, nmemb, stdout);
+    }
+
+    PyEval_ReleaseThread(tmp_state);
+    return ret;
+}
+
 static size_t
 header_callback(char *ptr, size_t size, size_t nmemb, void *stream)
 {
@@ -1489,11 +1603,19 @@ read_callback(char *ptr, size_t size, size_t nmemb, void *stream)
         goto verbose_error;
 
     /* handle result */
+#if PY_MAJOR_VERSION >= 3
+    if (PyBytes_Check(result)) {
+#else
     if (PyString_Check(result)) {
+#endif
         char *buf = NULL;
         Py_ssize_t obj_size = -1;
         Py_ssize_t r;
+#if PY_MAJOR_VERSION >= 3
+        r = PyBytes_AsStringAndSize(result, &buf, &obj_size);
+#else
         r = PyString_AsStringAndSize(result, &buf, &obj_size);
+#endif
         if (r != 0 || obj_size < 0 || obj_size > total_size) {
             PyErr_Format(ErrorObject, "invalid return value for read callback %ld %ld", (long)obj_size, (long)total_size);
             goto verbose_error;
@@ -1857,7 +1979,12 @@ do_curl_setopt(CurlObject *self, PyObject *args)
     }
 
     /* Handle the case of string arguments */
+
+#if PY_MAJOR_VERSION >= 3
+    if (PyUnicode_Check(obj)) {
+#else
     if (PyString_Check(obj)) {
+#endif
         char *str = NULL;
         Py_ssize_t len = -1;
 
@@ -1912,8 +2039,13 @@ do_curl_setopt(CurlObject *self, PyObject *args)
                 return NULL;
             break;
         case CURLOPT_POSTFIELDS:
+#if PY_MAJOR_VERSION >= 3
+            if (PyUnicode_AsStringAndSize(obj, &str, &len) != 0)
+                return NULL;
+#else
             if (PyString_AsStringAndSize(obj, &str, &len) != 0)
                 return NULL;
+#endif
             /* automatically set POSTFIELDSIZE */
             if (len <= INT_MAX) {
                 res = curl_easy_setopt(self->handle, CURLOPT_POSTFIELDSIZE, (long)len);
@@ -1989,7 +2121,12 @@ do_curl_setopt(CurlObject *self, PyObject *args)
 #undef IS_OFF_T_OPTION
 
     /* Handle the case of file objects */
+#if PY_MAJOR_VERSION >= 3
+    extern PyTypeObject PyIOBase_Type;
+    if(PyObject_IsInstance(obj, (PyObject *)&PyIOBase_Type) == 1) {
+#else
     if (PyFile_Check(obj)) {
+#endif
         FILE *fp;
 
         /* Ensure the option specified a file as well as the input */
@@ -2008,6 +2145,10 @@ do_curl_setopt(CurlObject *self, PyObject *args)
             return NULL;
         }
 
+#if PY_MAJOR_VERSION >= 3
+        int fd = PyObject_AsFileDescriptor(obj);
+        fp = fdopen(fd, "w");
+#else
         fp = PyFile_AsFile(obj);
         if (fp == NULL) {
             PyErr_SetString(PyExc_TypeError, "second argument must be open file");
@@ -2017,6 +2158,7 @@ do_curl_setopt(CurlObject *self, PyObject *args)
         if (res != CURLE_OK) {
             CURLERROR_RETVAL();
         }
+#endif
         Py_INCREF(obj);
 
         switch (option) {
@@ -2099,14 +2241,26 @@ do_curl_setopt(CurlObject *self, PyObject *args)
                     PyErr_SetString(PyExc_TypeError, "tuple must contain two elements (name, value)");
                     return NULL;
                 }
+#if PY_MAJOR_VERSION >= 3
+                if (PyUnicode_AsStringAndSize(PyTuple_GET_ITEM(listitem, 0), &nstr, &nlen) != 0) {
+#else
                 if (PyString_AsStringAndSize(PyTuple_GET_ITEM(listitem, 0), &nstr, &nlen) != 0) {
+#endif
                     curl_formfree(post);
                     PyErr_SetString(PyExc_TypeError, "tuple must contain string as first element");
                     return NULL;
                 }
+#if PY_MAJOR_VERSION >= 3
+                if (PyUnicode_Check(PyTuple_GET_ITEM(listitem, 1))) {
+#else
                 if (PyString_Check(PyTuple_GET_ITEM(listitem, 1))) {
+#endif
                     /* Handle strings as second argument for backwards compatibility */
+#if PY_MAJOR_VERSION >= 3
+                    PyUnicode_AsStringAndSize(PyTuple_GET_ITEM(listitem, 1), &cstr, &clen);
+#else
                     PyString_AsStringAndSize(PyTuple_GET_ITEM(listitem, 1), &cstr, &clen);
+#endif
                     /* INFO: curl_formadd() internally does memdup() the data, so
                      * embedded NUL characters _are_ allowed here. */
                     res = curl_formadd(&post, &last,
@@ -2160,7 +2314,11 @@ do_curl_setopt(CurlObject *self, PyObject *args)
                             curl_formfree(post);
                             return NULL;
                         }
+#if PY_MAJOR_VERSION >= 3
+                        if (!PyUnicode_Check(PyTuple_GET_ITEM(t, j+1))) {
+#else
                         if (!PyString_Check(PyTuple_GET_ITEM(t, j+1))) {
+#endif
                             PyErr_SetString(PyExc_TypeError, "value must be string");
                             PyMem_Free(forms);
                             curl_formfree(post);
@@ -2178,7 +2336,11 @@ do_curl_setopt(CurlObject *self, PyObject *args)
                             curl_formfree(post);
                             return NULL;
                         }
+#if PY_MAJOR_VERSION >= 3
+                        PyUnicode_AsStringAndSize(PyTuple_GET_ITEM(t, j+1), &ostr, &olen);
+#else
                         PyString_AsStringAndSize(PyTuple_GET_ITEM(t, j+1), &ostr, &olen);
+#endif
                         forms[k].option = val;
                         forms[k].value = ostr;
                         ++k;
@@ -2229,7 +2391,11 @@ do_curl_setopt(CurlObject *self, PyObject *args)
             struct curl_slist *nlist;
             char *str;
 
+#if PY_MAJOR_VERSION >= 3
+            if (!PyUnicode_Check(listitem)) {
+#else
             if (!PyString_Check(listitem)) {
+#endif
                 curl_slist_free_all(slist);
                 PyErr_SetString(PyExc_TypeError, "list items must be string objects");
                 return NULL;
@@ -2445,7 +2611,11 @@ do_curl_getinfo(CurlObject *self, PyObject *args)
             /* If the resulting string is NULL, return None */
             if (s_res == NULL)
                 Py_RETURN_NONE;
+#if PY_MAJOR_VERSION >= 3
+            return PyUnicode_FromString(s_res);
+#else
             return PyString_FromString(s_res);
+#endif
         }
 
     case CURLINFO_CONNECT_TIME:
@@ -3304,6 +3474,115 @@ static PyObject *curlobject_constants = NULL;
 static PyObject *curlmultiobject_constants = NULL;
 static PyObject *curlshareobject_constants = NULL;
 
+#if PY_MAJOR_VERSION >= 3
+static PyObject *
+my_getattro(PyObject *co, PyObject *name, PyObject *dict1, PyObject *dict2, PyMethodDef *m)
+{
+	PyObject *v = NULL;
+	if( v == NULL && dict1 != NULL )
+		v = PyDict_GetItem(dict1, name);
+	if( v == NULL && dict2 != NULL )
+		v = PyDict_GetItem(dict2, name);
+	if( v != NULL )
+	{
+		Py_INCREF(v);
+		return v;
+	}
+	return NULL;
+}
+
+static int
+my_setattro(PyObject **dict, PyObject *name, PyObject *v)
+{
+	if( *dict == NULL )
+	{
+		*dict = PyDict_New();
+		if( *dict == NULL )
+			return -1;
+	}
+	return PyDict_SetItem(*dict, name, v);
+}
+
+PyObject *do_curl_getattro(PyObject *o, PyObject *n)
+{
+	PyObject *v = PyObject_GenericGetAttr(o, n);
+	if( !v && PyErr_ExceptionMatches(PyExc_AttributeError) )
+	{
+		PyErr_Clear();
+		v = my_getattro(o, n, ((CurlObject *)o)->dict,
+						curlobject_constants, curlobject_methods);
+	}
+	return v;
+}
+
+static int
+do_curl_setattro(PyObject *o, PyObject *name, PyObject *v)
+{
+	assert_curl_state((CurlObject *)o);
+	if( v )
+	{
+		return my_setattro(&((CurlObject *)o)->dict, name, v);
+	} else
+	{
+		return PyObject_GenericSetAttr(o, name, 0);
+	}
+}
+
+static PyObject *
+do_multi_getattro(PyObject *o, PyObject *n)
+{
+	assert_multi_state((CurlMultiObject *)o);
+	PyObject *v = PyObject_GenericGetAttr(o, n);
+	if( !v && PyErr_ExceptionMatches(PyExc_AttributeError) )
+	{
+		PyErr_Clear();
+		v = my_getattro(o, n, ((CurlMultiObject *)o)->dict,
+						curlmultiobject_constants, curlmultiobject_methods);
+	}
+	return v;
+}
+
+static int
+do_multi_setattro(PyObject *o, PyObject *n, PyObject *v)
+{
+	assert_multi_state((CurlMultiObject *)o);
+	if( v )
+	{
+		return my_setattro(&((CurlMultiObject *)o)->dict, n, v);
+	} else
+	{
+		return PyObject_GenericSetAttr(o, n, 0);
+	}
+}
+
+static PyObject *
+do_share_getattro(PyObject *o, PyObject *n)
+{
+	assert_share_state((CurlShareObject *)o);
+	PyObject *v = PyObject_GenericGetAttr(o, n);
+	if( !v && PyErr_ExceptionMatches(PyExc_AttributeError) )
+	{
+		PyErr_Clear();
+		v = my_getattro(o, n, ((CurlShareObject *)o)->dict,
+						curlshareobject_constants, curlshareobject_methods);
+	}
+	return v;
+}
+
+static int
+do_share_setattro(PyObject *o, PyObject *n, PyObject *v)
+{
+	assert_share_state((CurlShareObject *)o);
+	if( v )
+	{
+		return my_setattro(&((CurlShareObject *)o)->dict, n, v);
+	} else
+	{
+		return PyObject_GenericSetAttr(o, n, 0);
+	}
+}
+
+#else
 static int
 my_setattr(PyObject **dict, char *name, PyObject *v)
 {
@@ -3382,10 +3661,53 @@ do_multi_getattr(CurlMultiObject *co, char *name)
     return my_getattr((PyObject *)co, name, co->dict,
                       curlmultiobject_constants, curlmultiobject_methods);
 }
+#endif
 
 
 /* --------------- actual type definitions --------------- */
 
+#if PY_MAJOR_VERSION >= 3
+static PyTypeObject CurlShare_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "pycurl.CurlShare", /* tp_name */
+    sizeof(CurlShareObject), /* tp_basicsize */
+    0,                         /* tp_itemsize */
+    (destructor)do_share_dealloc,/* tp_dealloc */
+    0,                         /* tp_print */
+    0,                         /* tp_getattr */
+    0,                         /* tp_setattr */
+    0,                         /* tp_reserved */
+    0,                         /* tp_repr */
+    0,                         /* tp_as_number */
+    0,                         /* tp_as_sequence */
+    0,                         /* tp_as_mapping */
+    0,                         /* tp_hash  */
+    0,                         /* tp_call */
+    0,                         /* tp_str */
+    (getattrofunc)do_share_getattro, /* tp_getattro */
+    (setattrofunc)do_share_setattro, /* tp_setattro */
+    0,                         /* tp_as_buffer */
+    Py_TPFLAGS_HAVE_GC,        /* tp_flags */
+    0,                         /* tp_doc */
+    (traverseproc)do_share_traverse, /* tp_traverse */
+    (inquiry)do_share_clear,      /* tp_clear */
+    0,                       /* tp_richcompare */
+    0,                       /* tp_weaklistoffset */
+    0,                       /* tp_iter */
+    0,                       /* tp_iternext */
+    curlshareobject_methods,          /* tp_methods */
+    0,                       /* tp_members */
+    0,                       /* tp_getset */
+    0,                       /* tp_base */
+    0,                       /* tp_dict */
+    0,                       /* tp_descr_get */
+    0,                       /* tp_descr_set */
+    0,                       /* tp_dictoffset */
+    0,                       /* tp_init */
+    0,                       /* tp_alloc */
+    0,                       /* tp_new */
+};
+#else
 static PyTypeObject CurlShare_Type = {
     PyObject_HEAD_INIT(NULL)
     0,                          /* ob_size */
@@ -3416,7 +3738,50 @@ static PyTypeObject CurlShare_Type = {
      * safely ignore any compiler warnings about missing initializers.
      */
 };
+#endif
 
+#if PY_MAJOR_VERSION >= 3
+static PyTypeObject Curl_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "pycurl.Curl",             /* tp_name */
+    sizeof(CurlObject), /* tp_basicsize */
+    0,                         /* tp_itemsize */
+    (destructor)do_curl_dealloc,/* tp_dealloc */
+    0,                         /* tp_print */
+    0,                         /* tp_getattr */
+    0,                         /* tp_setattr */
+    0,                         /* tp_reserved */
+    0,                         /* tp_repr */
+    0,                         /* tp_as_number */
+    0,                         /* tp_as_sequence */
+    0,                         /* tp_as_mapping */
+    0,                         /* tp_hash  */
+    0,                         /* tp_call */
+    0,                         /* tp_str */
+    (getattrofunc)do_curl_getattro, /* tp_getattro */
+    (setattrofunc)do_curl_setattro, /* tp_setattro */
+    0,                         /* tp_as_buffer */
+    Py_TPFLAGS_HAVE_GC,        /* tp_flags */
+    0,                         /* tp_doc */
+    (traverseproc)do_curl_traverse, /* tp_traverse */
+    (inquiry)do_curl_clear,      /* tp_clear */
+    0,                       /* tp_richcompare */
+    0,                       /* tp_weaklistoffset */
+    0,                       /* tp_iter */
+    0,                       /* tp_iternext */
+    curlobject_methods,          /* tp_methods */
+    0,                       /* tp_members */
+    0,                       /* tp_getset */
+    0,                       /* tp_base */
+    0,                       /* tp_dict */
+    0,                       /* tp_descr_get */
+    0,                       /* tp_descr_set */
+    0,                       /* tp_dictoffset */
+    0,                       /* tp_init */
+    0,                       /* tp_alloc */
+    0,                       /* tp_new */
+};
+#else
 static PyTypeObject Curl_Type = {
     PyObject_HEAD_INIT(NULL)
     0,                          /* ob_size */
@@ -3447,7 +3812,50 @@ static PyTypeObject Curl_Type = {
      * safely ignore any compiler warnings about missing initializers.
      */
 };
+#endif
 
+#if PY_MAJOR_VERSION >= 3
+static PyTypeObject CurlMulti_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0)
+    "pycurl.CurlMulti",             /* tp_name */
+    sizeof(CurlMultiObject), /* tp_basicsize */
+    0,                         /* tp_itemsize */
+    (destructor)do_multi_dealloc,/* tp_dealloc */
+    0,                         /* tp_print */
+    0, // (getattrfunc)do_curl_getattr,  /* tp_getattr */
+    0, //(setattrfunc)do_curl_setattr,  /* tp_setattr */
+    0,                         /* tp_reserved */
+    0,                         /* tp_repr */
+    0,                         /* tp_as_number */
+    0,                         /* tp_as_sequence */
+    0,                         /* tp_as_mapping */
+    0,                         /* tp_hash  */
+    0,                         /* tp_call */
+    0,                         /* tp_str */
+    (getattrofunc)do_multi_getattro, //0,                         /* tp_getattro */
+    (setattrofunc)do_multi_setattro,                         /* tp_setattro */
+    0,                         /* tp_as_buffer */
+    Py_TPFLAGS_HAVE_GC,        /* tp_flags */
+    0,                         /* tp_doc */
+    (traverseproc)do_multi_traverse, /* tp_traverse */
+    (inquiry)do_multi_clear,      /* tp_clear */
+    0,                       /* tp_richcompare */
+    0,                       /* tp_weaklistoffset */
+    0,                       /* tp_iter */
+    0,                       /* tp_iternext */
+    curlmultiobject_methods, /* tp_methods */
+    0,                       /* tp_members */
+    0,                       /* tp_getset */
+    0,                       /* tp_base */
+    0,                       /* tp_dict */
+    0,                       /* tp_descr_get */
+    0,                       /* tp_descr_set */
+    0,                       /* tp_dictoffset */
+    0,                       /* tp_init */
+    0,                       /* tp_alloc */
+    0,                       /* tp_new */
+};
+#else
 static PyTypeObject CurlMulti_Type = {
     PyObject_HEAD_INIT(NULL)
     0,                          /* ob_size */
@@ -3478,6 +3886,7 @@ static PyTypeObject CurlMulti_Type = {
      * safely ignore any compiler warnings about missing initializers.
      */
 };
+#endif
 
 static int
 are_global_init_flags_valid(int flags)
@@ -3539,7 +3948,11 @@ static PyObject *vi_str(const char *s)
         Py_RETURN_NONE;
     while (*s == ' ' || *s == '\t')
         s++;
+#if PY_MAJOR_VERSION >= 3
+    return PyUnicode_FromString(s);
+#else
     return PyString_FromString(s);
+#endif
 }
 
 static PyObject *
@@ -3666,7 +4079,11 @@ insobj2(PyObject *dict1, PyObject *dict2, char *name, PyObject *value)
         goto error;
     if (value == NULL)
         goto error;
+#if PY_MAJOR_VERSION >= 3
+    key = PyUnicode_FromString(name);
+#else
     key = PyString_FromString(name);
+#endif
     if (key == NULL)
         goto error;
 #if 0
@@ -3693,7 +4110,11 @@ error:
 static void
 insstr(PyObject *d, char *name, char *value)
 {
+#if PY_MAJOR_VERSION >= 3
+    PyObject *v = PyUnicode_FromString(value);
+#else    
     PyObject *v = PyString_FromString(value);
+#endif
     insobj2(d, NULL, name, v);
 }
 
@@ -3726,6 +4147,20 @@ insint_m(PyObject *d, char *name, long value)
 }
 
 
+#if PY_MAJOR_VERSION >= 3
+static PyModuleDef curlmodule = {
+    PyModuleDef_HEAD_INIT,
+    "pycurl",
+    module_doc,
+    -1,
+    curl_methods, NULL, NULL, NULL, NULL
+};
+#endif
+
+
+#if PY_MAJOR_VERSION >= 3
+PyMODINIT_FUNC PyInit_pycurl(void)
+#else
 /* Initialization function for the module */
 #if defined(PyMODINIT_FUNC)
 PyMODINIT_FUNC
@@ -3736,6 +4171,7 @@ extern "C"
 DL_EXPORT(void)
 #endif
 initpycurl(void)
+#endif
 {
     PyObject *m, *d;
     const curl_version_info_data *vi;
@@ -3750,8 +4186,23 @@ initpycurl(void)
     Py_TYPE(&CurlShare_Type) = &PyType_Type;
 
     /* Create the module and add the functions */
+#if PY_MAJOR_VERSION >= 3
+    if (PyType_Ready(&Curl_Type) < 0)
+        return NULL;
+
+    if (PyType_Ready(&CurlMulti_Type) < 0)
+        return NULL;
+
+
+    m = PyModule_Create(&curlmodule);
+    if (m == NULL)
+        return NULL;
+
+    Py_INCREF(&Curl_Type);
+#else
     m = Py_InitModule3("pycurl", curl_methods, module_doc);
     assert(m != NULL && PyModule_Check(m));
+#endif
 
     /* Add error object to the module */
     d = PyModule_GetDict(m);
@@ -4256,6 +4707,9 @@ initpycurl(void)
     PyEval_InitThreads();
 #endif
 
+#if PY_MAJOR_VERSION >= 3
+	return m;
+#endif
 }
 
 /* vi:ts=4:et:nowrap
-- 
1.7.1


From 5b123a6bc14a1382aea0d2a89b708ad6cb3ec3e6 Mon Sep 17 00:00:00 2001
From: Kamil Dudka <kdudka@redhat.com>
Date: Mon, 4 Nov 2013 18:45:21 +0100
Subject: [PATCH 2/3] python3: PyString_FromFormat -> PyUnicode_FromFormat

---
 src/pycurl.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/src/pycurl.c b/src/pycurl.c
index 9b27370..e962002 100644
--- a/src/pycurl.c
+++ b/src/pycurl.c
@@ -148,6 +148,7 @@ static void pycurl_ssl_cleanup(void);
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_FromLong               PyLong_FromLong
   #define PyInt_AsLong                 PyLong_AsLong
+  #define PyString_FromFormat          PyUnicode_FromFormat
 #endif
 
 
-- 
1.7.1


From ffa51525b49771aea56367e5aa4a9b2c0f3c57c8 Mon Sep 17 00:00:00 2001
From: Kamil Dudka <kdudka@redhat.com>
Date: Mon, 4 Nov 2013 19:08:38 +0100
Subject: [PATCH 3/3] python3: fix a compile-time warning

---
 src/pycurl.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/src/pycurl.c b/src/pycurl.c
index e962002..e15d26d 100644
--- a/src/pycurl.c
+++ b/src/pycurl.c
@@ -291,7 +291,7 @@ int PyUnicode_AsStringAndSize(PyObject *obj, char **buffer, Py_ssize_t *length)
 {
 	Py_ssize_t pysize = PyUnicode_GetSize(obj);
 	wchar_t * str = (wchar_t *) malloc((pysize + 1) * sizeof(wchar_t));
-	PyUnicode_AsWideChar((PyUnicodeObject *) obj, str, pysize);
+	PyUnicode_AsWideChar(obj, str, pysize);
 	str[pysize] = '\0';
 
     /* measure size */
-- 
1.7.1

